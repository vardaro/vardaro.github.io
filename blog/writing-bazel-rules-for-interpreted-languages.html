<!DOCTYPE html>
<html lang="en">
   <head>
      <!-- Basic Page Needs
         –––––––––––––––––––––––––––––––––––––––––––––––––– -->
      <meta charset="utf-8" />
      <title>Writing Bazel Rules for Interpreted Languages</title>
      <meta name="description" content="Anthony Vardaro, Software engineer" />
      <meta name="author" content="Anthony Vardaro" />
      <!-- Mobile Specific Metas
         –––––––––––––––––––––––––––––––––––––––––––––––––– -->
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <!-- CSS
         –––––––––––––––––––––––––––––––––––––––––––––––––– -->
      <link rel="stylesheet" href="../css/normalize.css" />
      <link rel="stylesheet" href="../css/skeleton.css" />
      <link rel="stylesheet" href="../css/custom.css" />
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/default.min.css">
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js"></script>
      <script>
         hljs.initHighlightingOnLoad();
      </script>
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111662471-1"></script>
      <script>
         window.dataLayer = window.dataLayer || [];
         
         function gtag() {
             dataLayer.push(arguments);
         }
         gtag("js", new Date());
         
         gtag("config", "UA-111662471-1");
      </script>
   </head>
   <body>
      <div class="container">
         <div class="row">
            <h3 id="home-title">Writing Bazel Rules for Interpreted Languages</h3>
            <p><a href="/">Anthony A. Vardaro</a>, Apr 2022</p>
         </div>
         <div class="row">
            <p>
               One of Bazel's most useful features is that it can support any language, allowing you to consolidate the build system into one tool.
               For small projects, it's <i>whatever</i>.
               For polyglot monorepos, it's hugely valuable for building targets with multi-language cross-dependencies.
               This article highlights Bazel's flexibility in extending the build system with custom plugins written in Starlark.
               We'll be doing this to extend Bazel to support Python. Not that Python rules don't exist already, <a href="https://github.com/bazelbuild/rules_python">they do</a>,
               but learning how to extend Bazel is both a valuable skill and kind of fun in small doses.
            </p>
            <p>
               The goal here is to implement a simple executable rule, <code>py_binary</code>, which produces a Python executable from a set of source files and dependencies.
               We'll also implement the <code>py_library</code> rule, for selecting and preparing source files for consumption by <code>py_binary</code> as a dependency.
               Neither of which are particularly difficult to write, but getting familiar with Bazel's evaluation model can be a little tricky.
               Also, I chose to emphasize writing rules for interpreted languages, like Python, as the process is a little different than writing rules for static, compiled languages.
               We'll be working out of this <a href="https://github.com/vardaro/rules_py_simple">example repository</a>.
            </p>
         </div>
         <div class="row">
            <h5>Concepts</h5>
            <p>
               In the simplest terms, a build target is a mapping between a defined set of inputs and a defined set of outputs. 
               A rule is simply the interface through which the defined are converted into defined outputs.
               They feel and behave like functions, like you would expect in programming or mathematics.
               When evaluating a build, Bazel makes clever assumptions on affected inputs to determine which outputs need to be reconstructed.
            </p>
            <p>
               For interpreted languages, there's nothing to really <i>build</i> per se, as dependency evaluation is deferred to runtime.
               This is different than languages like Go, where a rule implementation would register an action that wraps <code>go tool compile</code>, or something like that.
               For interpreted languages, the role of a <code>_binary</code> rule is to construct a runfile tree and provide a bash script to launch the binaries entry.
               A runfile is a file that a binary expects to be available at runtime.
               For Python, this is pretty much every <code>.py</code> source file (direct and transitive).
            </p>
         </div>
         <div class="row">
            <h5>Writing our Binary Rule</h5>
            <p>
               Let's start by giving it a name and some attributes:
            </p>
            <pre><code class="language-python"> # internal/py_binary.bzl
def _py_binary_impl(cx):
   pass

py_binary = rule(
    implementation = _py_binary_impl,
    attrs = {
        "srcs": attr.label_list(
            allow_files = True,
            doc = "Source files to compile",
        ),
        "deps": attr.label_list(
            doc = "Direct dependencies of the binary",
        ),
        "data": attr.label_list(
            allow_files = True,
            doc = "Data files available to binary at runtime",
        ),

        # This doesn't really need to be mandatory, I'm choosing to do so to keep the example simple.
        "main": attr.label(
            allow_single_file = True,
            mandatory = True,
            doc = "Label denoting the entrypoint of the binary",
        ),

        # Our rule is going to register an action to expand whatever template this attribute points to.
        "_bash_runner_tpl": attr.label(
            default = "@rules_py_simple//internal:py_binary_runner.bash.tpl",
            doc = "Label denoting the bash runner template to use for the binary",
            allow_single_file = True,
        ),

        # Bazel ships with a useful bash function for querying the absolute path to runfiles at runtime.
        "_bash_runfile_helper": attr.label(
            default = "@bazel_tools//tools/bash/runfiles",
            doc = "Label pointing to bash runfile helper",
            allow_single_file = True,
        ),
    },
    executable = True,

    # You pass a toolchain_type target here.
    # In this case, we use a builtin toolchain_type that was registered in a previous
    # blog post: https://www.anthonyvardaro.com/blog/hermetic-python-toolchain-with-bazel
    toolchains = ["@bazel_tools//tools/python:toolchain_type"],
    doc = "Builds a Python executable from source files and dependencies.",
)
</code></pre>
            <p>
               Pretty standard Bazel boilerplate stuff here.
               The <code>_bash_runner_tpl</code> points to a file that we'll write later in the post.
               At build time, our rule is going to register an action to expand said template into a default output of the rule.
               The <code>_bash_runfile_helper</code> is a Bazel-builtin library that provides a useful Bash function, <code>rlocation</code>, for querying runfiles from a Bash launcher script at runtime.
               It's <i>sort of</i> documented <a href="https://github.com/bazelbuild/bazel/blob/master/tools/bash/runfiles/runfiles.bash">here</a>.
               The Python toolchain I've configured points to a <code>toolchain_type</code> I configured in a previous blog post, <a href="https://www.anthonyvardaro.com/blog/hermetic-python-toolchain-with-bazel">Hermetic Python Toolchain with Bazel</a>.
            </p>
            <p>
               Let's declare our executable:
            </p>
            <pre><code class="language-python"># internal/py_binary.bzl
def _py_binary_impl(ctx):
    """
    py_binary implementation

    Produces a bash script for launching a Python binary using the toolchain
    registered in "@bazel_tools//tools/python:toolchain_type".

    Args:
        ctx: Analysis context
    """
    executable = ctx.actions.declare_file(ctx.label.name)
</pre></code>
            <p>
               As far as binary rules go, this is pretty standard.
               This notifies Bazel that we expect one of the actions registered in this rule to produce a file named after the target.
            </p>
            
            <p>
               Let's construct our runfile tree:
            </p>
            <pre><code class="language-python"> # internal/py_binary.bzl
interpreter = ctx.toolchains["@bazel_tools//tools/python:toolchain_type"].py3_runtime.interpreter

# File targets to be included in runfile object (i.e. the default outputs)
files = [
    ctx.file.main,
    executable,
    interpreter,
    ctx.file._bash_runfile_helper,
]

files.extend(ctx.files.srcs)
files.extend(ctx.files.data)

# Merge the current runfiles objects with all of the
# transitive runfile trees (all of which would return the
# requested DefaultInfo provider)
runfiles = ctx.runfiles(files = files)
runfiles = runfiles.merge_all([
    dep[DefaultInfo].default_runfiles
    for dep in ctx.attr.deps
])
</code></pre>
            <p>
               Here we're constructing a runfile object composed of the interpreter, launcher script, Bash library, and all of the relevant source files known to the target.
            </p>
            </p>
               Because we specified <code>@bazel_tools//tools/python:toolchain_type</code> as a compatible toolchain in the rule definition, we're able to query that toolchain and access the <code>PyRuntimeInfo</code> provider that it returns.
               This provides us with the <code>filegroup</code> target that points to the <code>python3</code> executable we'll need to launch our binary.
               This also technically means that the Python interpreter itself must be a runfile, hence we include it in the <code>files</code> list.
            </p>
            <p>
               We construct a new runfiles object and then merge in any transitive runfiles found in the <code>DefaultInfo</code> providers returned by the targets in <code>ctx.attr.deps</code>.
               To avoid quadratic time and space usage, it's encouraged to use a <code>depset</code> to aggregate transitive dependency sets, as opposed to using a list.
               A <code>depset</code> is a special purpose data structure unique to Bazel. 
               It's designed for efficiently merging information accumulated across dependent build targets.
               Their usage is not limited to file targets, you can technically use a <code>depset</code> to manage any kind of information.
               The general rule of thumb is that for information local to a rule, a list of dict is safe to use, for information passed to other rules via a provider, a <code>depset</code> is preferred.
            </p>

            <p>
            We then take our <code>py_runtime</code> and pass it to a <code>py_runtime_pair</code> target. The <code>py_runtime_pair</code> rule is a rule for coupling a Python2 and Python3 runtime into the same toolchain. It returns a <code>ToolchainInfo</code> provider, which is an object propogated to rules that consume this toolchain. Because this is a hermetic Python3 implementation, we can pass <code>None</code> to the <code>py2_runtime</code>.
            </p>

            <p>
            Now we can pass our runtime pair to a <code>toolchain</code> target. This target describes a toolchains compatible host and execution platforms, and it's toolchain type. The toolchain type is simply an alias for naming certain kinds of toolchains. You can implement your own <code>toolchain_type</code>, but the one that ships with Bazel is sufficient for us. Again, we are taking advantage of string substitution to inject the compatible OS and CPU constraints.  
            </p>

            <p>
            That's pretty much it for our <code>BUILD.bazel</code> file template. Now we can implement our supporting <code>repository_rule</code>.
            </p>
         </div>

         <div class="row">
            <h5>Writing our Repository Rule</h5>
            <p>
               For our toolchain, we're going to implement a <a href="https://docs.bazel.build/versions/main/skylark/repository_rules.html">repository_rule</a> that downloads a Python distribution and generates a <code>BUILD.bazel</code> file that describes a toolchain.
            </p>
            <p>
               Let's describe our repository rule. Let's start by just giving it a name.
            </p>
            <pre><code class="language-python"># internal/python_interpreter.bzl
def _py_download(ctx):
    """
    Downloads a Python distribution and registers a toolchain target.
  
    Args:
        ctx: Repository context.
    """
    pass

py_download = repository_rule(
    implementation = _py_download,
    attrs = {},
)</code></pre>
            <p>
            The <code>repository_rule</code> function is a special builtin function for declaring a new repository rule. We're describing a new rule, named <code>py_download</code>, which will generate Python toolchain targets from a Python distribution. The <code>implementation</code> argument passes a callback function, <code>_py_download</code>, which implements the rule. The <a href="https://docs.bazel.build/versions/main/skylark/lib/repository_ctx.html">repository context</a> gets passed to the implementation function, which provides an API for handling the non-hermetic operations a repository rule allows you to do.
               Unlike conventional Bazel rules, repository rules do not have a return value. Their purpose is typically some variation of downloading an archive and generating a <code>BUILD.bazel</code> for it. The <code>attrs</code> argument takes a dictionary
               describing the attributes of the rule. Right now, it doesn't have any. We're able to call this from <code>WORKSPACE</code> now.
            </p>
            <pre><code class="language-python"># WORKSPACE
workspace(
    name = "rules_py_simple",
)

load("@rules_py_simple//internal:python_interpreter.bzl", "py_download")

py_download(
    name = "my_py_download",
)</code></pre>
            <p>
               Our rule doesn't do anything yet, let's give it some attributes.
            </p>
            <pre><code class="language-python"> # internal/python_interpreter.bzl
def _py_download(ctx):
    """
    Downloads a Python distribution and registers a toolchain target.
  
    Args:
        ctx: Repository context.
    """
    pass

py_download = repository_rule(
    implementation = _py_download,
    attrs = {
        "urls": attr.string_list(
            mandatory = True,
            doc = "String list of mirror URLs where the Python distribution can be downloaded.",
        ),
        "sha256": attr.string(
            mandatory = True,
            doc = "Expected SHA-256 sum of the archive.",
        ),
        "os": attr.string(
            mandatory = True,
            values = ["darwin", "linux", "windows"],
            doc = "Host operating system.",
        ),
        "arch": attr.string(
            mandatory = True,
            values = ["x86_64"],
            doc = "Host architecture.",
        ),
        "_interpreter_path": attr.string(
            default = "bin/python3",
            doc = "Path you'd expect the python interpreter binary to live.",
        ),
        "_build_tpl": attr.label(
            default = "@rules_py_simple//internal:BUILD.dist.bazel.tpl",
            doc = "Label denoting the BUILD file template that get's installed in the repo.",
        )
    },
)</pre></code>
            <p>
              We've created an attribute set for our users to describe their toolchain. All they need to do is provide our rule with a mirror URL, a digest, a target platform, and a target CPU, and our rule can handle the heavy lifting of generating the necessary toolchain bits.
            </p>
            <p>
            The compatible OS platforms that this rule can support are restricted to <code>darwin</code>, <code>linux</code>, and <code>windows</code>. The compatible CPU architectures are restricted to <code>x86_64</code>. Our implementation function should be able to take these flags and generate compatibility constraints for our toolchain.
            </p>
            <p>
              You'll notice the rule comes with the private attributes <code>_interpreter_path</code> and <code>_build_tpl</code>. The <code>_interpreter_path</code> path describes the path to the Python interpreter binary. In most cases, it lives in <code>bin/python3</code>, hence the attributed privacy and default setting. The <code>_build_tpl</code> attribute describes the base template of the injected <code>BUILD.bazel</code>. We wrote our own, but let's give users the option to patch what gets injected in the repository.
            </p>
            <p>
              Let's start implementing our callback function. Let's start by downloading the provided Python mirror URL.
            </p>
            <pre><code class="language-python"> # internal/python_interpreter.bzl
def _py_download(ctx):
    """
    Downloads a Python distribution and registers a toolchain target.

    Args:
        ctx: Repository context.
    """
    ctx.report_progress("downloading python")
    ctx.download_and_extract(
        url = ctx.attr.urls,
        sha256 = ctx.attr.sha256,
        stripPrefix = "python",
    )

    return None
</code></pre>
          <p>
          Pretty self-explanatory! The <code>repository_ctx</code> object comes pre-baked with a bunch of helper functions that help us achieve what we're trying to do here. In this case we can just give <code>download_and_extract()</code> the mirror URLs and expected digest, and it will extract the Python distribution into the repositores workspace root. 
          </p>
          <p>
            We need to figure out a way to map the values passed in the <code>os</code> and <code>arch</code> attributes to something Bazel can understand.
            Let's create a simple mapping that maps an attributes value to a Bazel label pointing to a <code>@platforms//</code> target.
          </p>
          <pre><code class="language-python"> # internal/python_interpreter.bzl
_OS_MAP = {
        "darwin": "@platforms//os:osx",
        "linux": "@platforms//os:linux",
        "windows": "@platforms//os:windows",
}

_ARCH_MAP = {
        "x86_64": "@platforms//cpu:x86_64",
}</code></pre>
          <p>
          Where do these labels come from? They come shipped with Bazel, but you can find their implementation <a href="https://github.com/bazelbuild/platforms">here</a>. The <code>target_compatible_with</code> and <code>exec_compatible_with</code> attributes of the <code>toolchain</code> will accept these labels, as they return the appropriate providers.
          </p>
          <p>
          Let's go ahead and generate some Starlark code for a label list of platform targets to get injected in the generated build file.
          </p>
          <pre><code class="language-python">ctx.report_progress("generating build file")
os_constraint = _OS_MAP[ctx.attr.os]
arch_constraint = _ARCH_MAP[ctx.attr.arch]

constraints = [os_constraint, arch_constraint]
    
# So Starlark doesn't throw an indentation error when this gets injected.
constraints_str = ",\n        ".join(['"%s"' % c for c in constraints])
</code></pre>
          We're taking our platform labels and generating Starlark code for a list literal. 
          Since Starlark relies on indentation for scoping blocks of code, we need to prefix the strings with whitespace, ugh. <code>constraints_str</code> will get propogated to the <code>toolchain</code> in the build file, which will end up looking something like this.
          <pre><code class="language-python"> # Generated BUILD.bazel file
toolchain(
    name = "toolchain",
    exec_compatible_with = [
	"@platforms//os:osx",
        "@platforms//cpu:x86_64",
    ],
    target_compatible_with = [
	"@platforms//os:osx",
        "@platforms//cpu:x86_64",
    ],
    toolchain = ":py_runtime_pair",
    toolchain_type = "@bazel_tools//tools/python:toolchain_type",
)</code></pre>
          </p>
          <p>
            Now all that's left is templating the <code>BUILD.bazel</code>, which is again made easy by the <code>repository_ctx</code>.
          </p>
          <pre><code class="language-python"># Inject our string substitutions into the BUILD file template, and drop said BUILD file in the WORKSPACE root of the repository.
substitutions = {
    "{constraints}": constraints_str,
    "{interpreter_path}": ctx.attr._interpreter_path,
}

ctx.template(
    "BUILD.bazel",
    ctx.attr._build_tpl,
    substitutions = substitutions,
)

return None
</code></pre>
          <p>
            That's it! The implementation is very straightforward. I believe the concepts are more difficult to grasp than the implementation, but they are important to know.
          </p>
          <p>
            Here's the entire rule. Let's take a moment to marvel and be amazed, then we'll head over to the <code>WORKSPACE</code> file to test out our new fancy rule.
          </p>
          <pre><code class="language-python"># internal/python_interpreter.bzl
_OS_MAP = {
        "darwin": "@platforms//os:osx",
        "linux": "@platforms//os:linux",
        "windows": "@platforms//os:windows",
}

_ARCH_MAP = {
        "x86_64": "@platforms//cpu:x86_64",
}

def _py_download(ctx):
    """
    Downloads a Python distribution and registers a toolchain target.

    Args:
        ctx: Repository context.
    """
    ctx.report_progress("downloading python")
    ctx.download_and_extract(
        url = ctx.attr.urls,
        sha256 = ctx.attr.sha256,
        stripPrefix = "python",
    )
    
    ctx.report_progress("generating build file") 
    os_constraint = _OS_MAP[ctx.attr.os]
    arch_constraint = _ARCH_MAP[ctx.attr.arch]

    constraints = [os_constraint, arch_constraint]
    
    # So Starlark doesn't throw an indentation error when this gets injected.
    constraints_str = ",\n        ".join(['"%s"' % c for c in constraints])

    # Inject our string substitutions into the BUILD file template, and drop said BUILD file in the WORKSPACE root of the repository.
    substitutions = {
        "{constraints}": constraints_str,
        "{interpreter_path}": ctx.attr._interpreter_path,
    }

    ctx.template(
        "BUILD.bazel",
        ctx.attr._build_tpl,
        substitutions = substitutions,
    )

    return None

py_download = repository_rule(
    implementation = _py_download,
    attrs = {
        "urls": attr.string_list(
            mandatory = True,
            doc = "String list of mirror URLs where the Python distribution can be downloaded.",
        ),
        "sha256": attr.string(
            mandatory = True,
            doc = "Expected SHA-256 sum of the archive.",
        ),
        "os": attr.string(
            mandatory = True,
            values = ["darwin", "linux", "windows"],
            doc = "Host operating system.",
        ),
        "arch": attr.string(
            mandatory = True,
            values = ["x86_64"],
            doc = "Host architecture.",
        ),
        "_interpreter_path": attr.string(
            default = "bin/python3",
            doc = "Path you'd expect the python interpreter binary to live.",
        ),
        "_build_tpl": attr.label(
            default = "@rules_py_simple//internal:BUILD.dist.bazel.tpl",
            doc = "Label denoting the BUILD file template that get's installed in the repo.",
        )
    },
)</code></pre>
         </div>
         <div class="row">
           <h5>Using our Repository Rule and Registering the Toolchain</h5>
           <p>
              Now that we have a rule that downloads a Python archive and produces toolchain targets, we just need to specify our toolchains in the <code>WORKSPACE</code> file and register them. Before diving in, let's first think about what kind of Python distribution we want to use.
            </p>
            <p>
              The Python interpreter by its nature has runtime dependencies on the host that do not get shipped with the distribution. This is annoying. It introduces unnecessary flakiness in our hermetic toolchain, as different host machines will have different
              versions of <code>ssl</code>, <code>zlib</code>, <code>ncurses</code>, etc. These installations can come from HomeBrew, Apt, or god knows what else. For this reason, I do not recommend using the official distributions from <a href="https://python.org/downloads/">python.org</a>, you will be unhappy.
              Fortunately for us, there is an awesome open-source project, <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>, which aims to produce a "self-contained, highly portable" distribution of Python. We'll use this.
           </p>
          
           </p>
           Let's define our toolchain repositories and then register them with the <code>register_toolchains</code> rule.
           </p>
           <pre><code class="language-python"> # WORKSPACE
workspace(
    name = "rules_py_simple",
)

load("@rules_py_simple//internal:python_interpreter.bzl", "py_download")

py_download(
    name = "py_darwin_x86_64",
    arch = "x86_64",
    os = "darwin",
    sha256 = "fc0d184feb6db61f410871d0660d2d560e0397c36d08b086dfe115264d1963f4",
    urls = ["https://github.com/indygreg/python-build-standalone/releases/download/20211017/cpython-3.10.0-x86_64-apple-darwin-install_only-20211017T1616.tar.gz"],
)

py_download(
    name = "py_linux_x86_64",
    arch = "x86_64",
    os = "linux",
    sha256 = "eada875c9b39cc4bf4a055dd8f5188e99c0c90dd5deb05b6c213f49482fe20a6",
    urls = ["https://github.com/indygreg/python-build-standalone/releases/download/20211017/cpython-3.10.0-x86_64-unknown-linux-gnu-install_only-20211017T1616.tar.gz"],
)

# The //:toolchain target points to the toolchain target we wrote in the BUILD file template.
register_toolchains(
    "@py_darwin_x86_64//:toolchain",
    "@py_linux_x86_64//:toolchain",
)</code></pre>
           <p>
            Our <code>py_download</code> rule generates Bazel repositories for each toolchain, which we can then pass to <code>register_toolchains</code>. At runtime, Bazel will evaluate the host and execution platforms, and select the correct toolchain to bundle with target you're trying to build.
           </p>
           <p>
            Let's do a quick test to see if everything works properly. Let's write a program that simply prints the version of its runtime.
           </p>
           <pre><code class="language-python"> # bin.py
import sys

print(sys.version)
</code></pre>
          <p>
            Write a <code>py_binary</code> target for it.
          <p>
          <pre><code class="language-python"> # BUILD.bazel
py_binary(
    name = "bin",
    srcs = ["bin.py"],
    visibility = ["//visibility:public"],
)</code></pre>
          <p>
            Running our binary, it should print <code>3.10.0</code> as the version (which is the one we pinned in the workspace file). And it does!
            The reason <code>py_binary</code> selects our toolchain instead of the builtin autodetecting one is because we registered our <code>toolchain_type</code> as <code>bazel_tools//tools/python:toolchain_type</code>,
            which is the type that <code>py_binary</code> natively expects.
          </p>
          <pre><code class="language-shell">$ bazel run bin
INFO: Analyzed target //:bin (15 packages loaded, 92 targets configured).
INFO: Found 1 target...
Target //:bin up-to-date:
  bazel-bin/bin
INFO: Elapsed time: 0.531s, Critical Path: 0.00s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
INFO: Build completed successfully, 1 total action
3.10.0 (default, Oct 18 2021, 00:33:47) [Clang 13.0.0 ]
</code></pre>
          </div>
          <div class="row">
            <h5>Done</h5>
            <p>
              The learning curve for extending Bazel is steeper than tranditional build systems like Make. Learning how to write effective rules will take some time.
              As I said earlier in the post, the implementation of this stuff tends to be very straightforward, but the surrounding concepts are complex. 
              I recommend you look around the <a href="https://github.com/vardaro/rules_py_simple">example repo</a> to help you conceptualize how everything fits together.
            </p>
          </div>
         <!-- footer  -->
         <div class="contact">
            <span class="contact-link">
            <a target="_blank" href="https://github.com/vardaro">Github</a>
            </span>
            <span class="contact-link">
            <a target="_blank" href="mailto:me@anthonyvardaro.com">Email</a>
            </span>
            <span class="contact-link">
            <a target="_blank" href="https://www.linkedin.com/in/anthony-vardaro-27a070138/">LinkedIn</a>
            </span>
         </div>
      </div>
   </body>
</html>
