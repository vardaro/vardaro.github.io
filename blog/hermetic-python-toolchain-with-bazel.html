<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <meta charset="utf-8" />
    <title>Hermetic Python toolchain with Bazel</title>
    <meta name="description" content="Anthony Vardaro, Software engineer" />
    <meta name="author" content="Anthony Vardaro" />

    <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <link rel="stylesheet" href="../css/normalize.css" />
    <link rel="stylesheet" href="../css/skeleton.css" />
    <link rel="stylesheet" href="../css/custom.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111662471-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag("js", new Date());

        gtag("config", "UA-111662471-1");
    </script>

</head>

<body>
    <div class="container">
        <div class="row">
            <h3 id="home-title">Hermetic Python toolchain with Bazel</h3>
            <p><a href="/">Anthony A. Vardaro</a>, Dec 2021</p>
        </div>
        <div class="row">
            <p>
              Here's how to quickly bootstrap a hermetic Python toolchain with Bazel.
            </p>
        </div>
    
        <div class="row">
          <h5>Motivation</h5>
          <p>
              The primary benefit in implementing your own Python toolchain is that it allows you to escape the dreaded autodetecting toolchain that ships with Bazel, labeled as <code>@bazel_tools//tools/python:_autodetecting_py_runtime_pair</code>.  
              This toolchain is dissapointingly non-hermetic. It depends on the host machines installation of Python, wherever and whatever that might be.  
              The default autodetecting toolchain attempts to resolve a Python runtime by examining the hosts <code>$PATH</code>, thus damaging reproducibility of Python builds across different host machines. It's completely dependent on the flaky <code>$PATH</code> variable,
              which could be modified by PyEnv, Apt, or whatever random Python you happen to have installed locally. This mean two developers building the same target will produce different binaries, which is very bad. As you can imagine, this becomes the source of numerous Github issues created by frustrated users who don't understand why their builds are not reproducible.
          </p>
          <p>
          The goal here is to implement our own heremtic Python toolchain, so that everyone is on the same page. We'll do this by writing a repository rule that downloads a pinned Python distribution and generates a <code>BUILD.bazel</code> that declares a constrained <code>toolchain</code> target.
                   
          </p>
        </div>
  
        <div class="row">
          <h5>Concepts and Terminology</h5>
          <p>
              If you're not familiar with Bazels complex toolchain ecosystem, the official documentation on <a href="https://docs.bazel.build/versions/main/toolchains.html">Toolchains</a> and <a href="https://docs.bazel.build/versions/main/platforms.html">Platforms</a> are worth your time.
          </p>
          <p>
            A <i>platform</i> is a named collection system constraints that describe where a build is intended to run. This is done by creating a <code><a href="https://docs.bazel.build/versions/main/be/platform.html#platform">platform</a></code> rule. At runtime, Bazel identifies three platform targets which serve different purposes. The <i>host platform</i> is the platform on which Bazel is running. For me, it'd be my laptop. The <i>execution platform</i> is the platform that Bazel executes <a href="https://docs.bazel.build/versions/main/skylark/lib/Action.html">actions</a> on. For me, it's still my laptop. If I were to use remote execution, the execution platform would be the platform of the execution environment, the host platform would still be my laptop. The <i>target platform</i> is the platform in which the final build is intended to run. If I were cross-compiling a target from a darwin host machine to a linux container, the host platform would be my laptop and the target platform would be the linux container.
          </p>
          <p>
            A <i>constraint</i> is an individual criteria that a platform must satisfy. Remember, a platform is simply a named collection of these constraints. Constraints allow you to add cardinality to your platform definitions. Bazel ships with <a href="https://github.com/bazelbuild/platforms">predefined platform definitions</a>, which is what we'll be using here.
          </p>
          <p>
            A <i>toolchain</i> is a special target that bundles a language-agnostic toolchain implementation, a toolchain type, and a set of supported platforms.
          </p>
    
          <p>
            How does this fit together? At runtime, Bazel will identify the registered toolchains, the host platform, and the execution platform. Using the constraints described in the toolchains, and the constraints described in the platform, Bazel will attempt to select suitable toolchain pairings for the host and execution platforms.    
            I recommend building something with the <code>--toolchain_resolution_debug=True</code>, as it will help you conceptualize Bazels fascinating toolchain resolution process.
          </p>
        </div>

        <div class="row">
            <h5>Including the Header Files</h5>
            <p>
                You need to expose the directory containing your header files in your <code>binding.gyp</code>. For me, they are within a subdirectory of my addon, so I can use the handy <code>module_root_dir</code> environment variable to reference it.
            </p>
            <pre><code>
{
    "include_dirs": [
        "<(module_root_dir)/tobii/include"
    ],
}
            </code></pre>
        </div>


        <div class="row">
            <h5>Linking the .lib Files</h5>
            <p>
                You also need to tell node-gyp where it can find the .lib files in your library.
            </p>
            <pre><code>
{
    "libraries": [
        "<(module_root_dir)/tobii/lib/x64/tobii_interaction_lib.lib",
        "<(module_root_dir)/tobii/lib/x64/tobii_stream_engine.lib"
    ],
}
            </code></pre>
        </div>


        <div class="row">
            <h5>Copy the DLLs to Your Target Build Folder</h5>
            <p>
                Specify where the DLLs are, and where to copy them at build. In my case, I'm building to
                <code>./build/Release/</code>. My <code>addon.node</code> target and both of my defined DLLs will be written to this directory.
            </p>
            <pre><code>
{
    "copies": [
        {
        "destination": "<(module_root_dir)/build/Release/",
            "files": [
                "<(module_root_dir)/tobii/lib/x64/tobii_interaction_lib.dll",
                "<(module_root_dir)/tobii/lib/x64/tobii_stream_engine.dll"
            ]
        },
    ]
}
            </code></pre>
        </div>

        <div class="row">
            <h5>The Finished <code>binding.gyp</code></h5>
            <p>
                Here is final product of the <code>binding.gyp</code> file.
            </p>
            <pre><code>
{
  "targets": [
    {
      "target_name": "addon",
      "sources": [
        "main.cc"
      ],
      "conditions": [
        [
          "OS==\"win\"",
          {
            "libraries": [
              "<(module_root_dir)/tobii/lib/x64/tobii_interaction_lib.lib",
              "<(module_root_dir)/tobii/lib/x64/tobii_stream_engine.lib"
            ],
            "include_dirs": [
              "<(module_root_dir)/tobii/include"
            ],
            "copies": [
              {
                "destination": "<(module_root_dir)/build/Release/",
                "files": [
                  "<(module_root_dir)/tobii/lib/x64/tobii_interaction_lib.dll",
                  "<(module_root_dir)/tobii/lib/x64/tobii_stream_engine.dll"
                ]
              }
            ]
          }
        ]
      ]
    }
  ]
}
            </code></pre>
        </div>

        <!-- footer  -->
        <div class="contact">
            <span class="contact-link">
        <a target="_blank" href="https://github.com/vardaro">Github</a>
      </span>
            <span class="contact-link">
        <a target="_blank" href="mailto:me@anthonyvardaro.com">Email</a>
      </span>
            <span class="contact-link">
        <a target="_blank" href="https://www.linkedin.com/in/anthony-vardaro-27a070138/">LinkedIn</a>
      </span>
        </div>
    </div>
</body>

</html>
